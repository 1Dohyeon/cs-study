## 1. 개요: "가장 가운데 있는 놈이 루트"

트리의 높이를 최소로 만들려면, 그래프에서 가장 구석진 곳이 아니라 **가장 중심부**에 있는 노드를 루트로 잡아야 합니다.

* **핵심 원리**: 트리의 중심 노드는 **최대 2개**까지만 존재할 수 있습니다.
* **전략**: 연결된 간선이 하나뿐인 노드(리프 노드)들을 단계별로 제거하다 보면, 마지막에 남는 1~2개의 노드가 바로 최소 높이 트리(MHT)의 루트가 됩니다.

## 2. 동작 로직: 양파 껍질 벗기기

### step 1

* `graph`: 인접 리스트로 트리 구조 저장.
* `degree`: 각 노드에 연결된 간선 수 (차수).
* `leaves`: 연결된 간선이 1개뿐인 노드들을 첫 번째 타겟으로 잡습니다.

### step 2: 리프 노드 제거 (Trim)

* `while remaining_nodes > 2`: 노드가 1개나 2개 남을 때까지 반복합니다.
* 현재 `leaves`에 담긴 노드들을 트리에서 떼어냅니다.
* **중요**: 떼어낸 노드와 연결되어 있던 이웃 노드들은 이제 간선이 하나 줄어듭니다 (`degree[neighbor] -= 1`).

### step 3: 새로운 리프 발견

* 간선이 줄어들어서 새로 리프(`degree == 1`)가 된 노드들을 `new_leaves`에 담아 다음 차례에 제거합니다.

## 3. 코드 시뮬레이션 (Example 2 기준)

**입력**: `n = 6`, `edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]`

1. **초기 상태**:
* 노드별 연결 수(`degree`): `{0:1, 1:1, 2:1, 3:4, 4:2, 5:1}`
* 첫 번째 리프(`leaves`): `[0, 1, 2, 5]`
* 남은 노드 수: 6개


2. **첫 번째 껍질 제거**:
* `0, 1, 2`를 제거하면서 연결된 `3`의 차수 감소: 
* `5`를 제거하면서 연결된 `4`의 차수 감소: 
* **새로운 리프 탄생**: `[3, 4]` (둘 다 차수가 1이 됨)
* 남은 노드 수: $6-4 = 2$개


3. **종료**:
* `remaining_nodes`가 2개가 되었으므로 `while`문 종료.
* **결과**: `[3, 4]` 반환.

## 4. 왜 이 방식이 효율적인가?

* **시간 복잡도**: . 모든 노드와 간선을 딱 한 번씩만 훑으면 끝나기 때문입니다.
* **완전 탐색과의 차이**:
* 모든 노드를 루트로 잡고 DFS를 돌리면 $O(N^2)$이 걸려 만 되어도 시간 초과가 납니다.
* 이 방식은 위상 정렬(Topological Sort)의 아이디어를 응용해 밖에서 안으로 빠르게 좁혀 들어갑니다.

## 요약

| 구성 요소 | 역할 | 비유 |
| --- | --- | --- |
| **`degree`** | 각 노드의 연결성 확인 | 이웃집이 몇 군데인지 체크 |
| **`leaves`** | 현재 제거할 노드 목록 | 가장 바깥쪽 껍질 |
| **`remaining_nodes > 2`** | 종료 조건 | 핵심(심지)이 1~2개 남을 때까지 |
| **`degree[neighbor] -= 1`** | 연결 끊기 | 길을 하나씩 폐쇄하기 |

