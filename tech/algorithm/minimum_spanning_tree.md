# Minimum Spanning Tree (최소 스패닝 트리, MST)

## MST 개요

최소 스패닝 트리는 **'최소 비용의 통신망 설계'** 와 같습니다. 모든 도시(노드)를 연결하되, 사이클(순환 고리)이 생기지 않게 하면서 **전체 연결 비용(간선의 가중치 합)을 최소로** 만드는 최적의 지도입니다.

- **스패닝 트리 (Spanning Tree)**: 모든 정점을 연결하는 부분 그래프로, 나무(Tree)처럼 사이클이 없는 구조입니다.
- **최소 가중치 (`total_weight`)**: 단순히 경로를 찾는 게 아니라, 사용된 모든 길의 비용을 합쳤을 때 가장 저렴해야 합니다.
- **방문 체크 리스트 (`visited`)**: 이미 통신망에 연결된 도시를 표시합니다. 한 번 연결된 도시는 다시 건드리지 않습니다.

## Python 프림 알고리즘

### 0. 지도와 도구 준비

- `graph`: "어느 지점에서 어느 지점으로 연결되어 있고, 비용은 얼마인가?" (무방향 그래프이므로 양방향 저장)
- `min_heap`: 현재 연결된 도시들에서 **갈 수 있는 다음 길들 중 가장 저렴한 길**을 찾기 위한 우선순위 큐입니다.

### 1. 프림(Prim) 함수 동작 원리

```python
import heapq

def prim(start):
    visited = [False] * (V + 1) # 도시 방문 여부 (연결됨 표시)
    min_heap = []
    
    # 1. 시작 도시를 선정하여 바구니에 넣습니다. (비용 0, 시작 노드)
    heapq.heappush(min_heap, (0, start))
    
    total_weight = 0 # 전체 공사 비용 합계
    edges_used = 0   # 연결된 다리 개수 (도시-1개가 되면 종료 가능)

    while min_heap:
        # 2. 바구니에서 "지금 당장 갈 수 있는 가장 싼 길"을 꺼냅니다.
        weight, node = heapq.heappop(min_heap)

        # 3. [중복 체크] 이미 통신망에 연결된 도시라면 무시합니다. (사이클 방지)
        if visited[node]:
            continue

        # 4. [방문 처리] 도시를 통신망에 연결하고 비용을 더합니다.
        visited[node] = True
        total_weight += weight
        edges_used += 1

        # 5. [이웃 탐색] 방금 연결한 도시에서 갈 수 있는 '새로운 길'들을 살펴봅니다.
        for next_weight, next_node in graph[node]:
            # 아직 연결되지 않은 도시로 가는 길이라면 대기열에 추가!
            if not visited[next_node]:
                heapq.heappush(min_heap, (next_weight, next_node))

    return total_weight

```

## 핵심 구성 요소의 역할

### 1. `min_heap` (가장 싼 재료 찾기)

프림 알고리즘은 **"현재 내가 가진 영역에서 가장 싼 간선을 선택하며 영역을 확장"** 하는 방식입니다. `min_heap`은 수많은 후보 간선 중 가장 저렴한 것을 단번에 찾아주는 역할을 합니다.

### 2. `visited` (중복 및 사이클 방지)

이미 내 통신망에 들어온 도시는 다시 방문할 필요가 없습니다. 만약 이미 방문한 도시를 또 연결한다면, 그것은 불필요한 **사이클(Cycle)** 을 만들게 되어 '트리' 구조가 깨지게 됩니다.

### 3. `total_weight` (누적 합계)

다익스트라는 "시작점부터 특정 지점까지의 누적 거리"를 계산하지만, MST는 **"사용한 간선 그 자체의 비용"** 만 계속 더해 나갑니다.


## 다익스트라 vs 프림(MST) 한눈에 비교

| 구분 | 다익스트라 (Dijkstra) | 프림 (Prim - MST) |
| --- | --- | --- |
| **목적** | 시작점에서 각 노드까지의 **최단 거리** | 모든 노드를 잇는 **최소 비용 합계** |
| **비용 계산** | `cost = dist + weight` (누적값) | `total_weight += weight` (간선 단일값) |
| **장부의 역할** | 각 노드까지의 최소 기록 업데이트 | 각 노드의 방문 여부(연결 여부) 체크 |
| **비유** | 가장 빠른 내비게이션 경로 찾기 | 가장 저렴한 재료로 모든 도시 연결하기 |

---

## 🏁 시뮬레이션 (1번 노드 시작 가정)

1. **1번 노드**를 `visited` 처리하고, 1번과 연결된 모든 길을 `min_heap`에 넣습니다.
2. `min_heap`에서 가장 가중치가 낮은(가장 싼) 간선을 하나 꺼냅니다.
3. 그 간선이 연결하는 도시가 **아직 안 가본 도시**라면?
    - `total_weight`에 비용을 더하고 `visited` 처리합니다.
    - 새로운 도시에서 갈 수 있는 길들을 다시 `min_heap`에 넣습니다.
4. 모든 도시가 연결될 때까지 반복합니다.

이렇게 하면 항상 **가장 저렴한 간선들만 골라 쓰면서** 모든 도시가 하나로 연결된 최적의 지도가 완성됩니다.

---

## 결정적 차이: 무엇을 더하는가?

가장 큰 차이는 **우선순위 큐에 넣는 값(`cost`)을 계산하는 방식**에 있습니다.


- **다익스트라:** "내가(출발점) 너(목적지)한테 가는 **가장 빠른 길**이 어디야?" (개인의 최단 경로)
- **MST(프림):** "모든 사람을 다 연결할 건데, **공사비를 최소로** 하려면 어떻게 이어야 해?" (전체의 최소 비용)


### 다익스트라 (누적 거리)

시작점에서부터 **지금까지 온 거리**를 계속 합산합니다.

* **계산:** `(현재까지 오는데 걸린 총 거리) + (다음 지점까지의 거리)`
* **관심사:** "내가 1번에서 출발했는데, 4번 집까지 총 얼마나 걸리지?"

### MST/프림 (단일 간선 비용)

시작점이 어디인지는 중요하지 않습니다. 그냥 **지금 연결된 덩어리에서 새로 뻗어나갈 길 중 가장 싼 것**을 고릅니다.

* **계산:** `(다음 지점까지의 거리)` 그 자체
* **관심사:** "지금 우리 마을에 전기선을 깔 건데, 안 연결된 옆 마을 중 선 제일 짧게 써서 연결할 수 있는 곳이 어디야?"

### 상황 비교

예를 들어 **1번(시작), 2번(중간), 3번(마지막)** 세 지점이 있고 길이 다음과 같다고 해봅시다.

* 1 --- 2 (비용 10)
* 2 --- 3 (비용 10)
* 1 --- 3 (비용 15)

#### 상황 A: 다익스트라 (1번에서 3번 친구네 가기)

* 1번에서 2번 거쳐 3번 가면: 
* 1번에서 3번 바로 가면: **15**
* **결과:** 1번과 3번을 직접 잇는 **15**짜리 길을 선택합니다.

#### 상황 B: MST (세 지점에 모두 전기 깔기)

* 1-3만 이으면 2번은 전기가 안 들어옵니다. 모두를 이어야 합니다.
* 방법 1: (1-3)과 (1-2) 연결 
* 방법 2: (1-2)와 (2-3) 연결 
* **결과:** 총합이 가장 저렴한 **20**짜리 구성(1-2, 2-3 연결)을 선택합니다.
* *이때 1번에서 3번 가는 길은 20이 되어 다익스트라(15)보다 멀어지지만, 전체 공사비는 아꼈습니다.*


### 요약 비교 테이블

| 구분 | 다익스트라 (Dijkstra) | 최소 스패닝 트리 (MST) |
| --- | --- | --- |
| **핵심 질문** | "출발지에서 각 지점까지 얼마나 멀어?" | "모든 지점을 잇는 총 비용이 얼마야?" |
| **비용 누적** | **있음** (시작점부터의 거리 합산) | **없음** (새로 추가할 간선의 비용만 확인) |
| **결과물** | 출발지 기준의 **방사형 최단 경로** | 전체를 잇는 **최소 비용의 그물망** |
| **실무 비유** | T맵, 카카오맵 (최단 시간 경로) | 광케이블/수도관 매립 공사 (최소 자재비) |

### 코드로 보는 한 줄 차이

두 알고리즘은 코드 구조가 90% 일치하지만, 이 **한 줄**이 모든 것을 바꿉니다.

```python
# 다익스트라
new_dist = current_dist + weight  # '지금까지 온 거리'를 더함
if new_dist < distance[next_node]:
    distance[next_node] = new_dist

# 프림(MST)
if not visited[node]:
    visited[node] = True
    total_weight += weight
```

**"모든 정점을 연결"** 하라는 말이 있다면 거의 **MST**를 사용하면 됩니다.

---

## Python 크루스칼(Kruskal) 알고리즘

프림이 **"한 지점에서 세력을 넓히는 방식"** 이라면, 크루스칼은 **"비용이 싼 길부터 일단 다 순서대로 세우고, 사이클만 안 생기면 다리를 놓는 방식"** 입니다. 이때 사이클 여부를 확인하기 위해 **Union-Find**라는 도구가 필요합니다.

### Union-Find: 사이클 판독기

```python
# 특정 노드가 속한 집합의 루트를 찾음 (Find)
def find_parent(parent, x):
    if parent[x] != x:
        parent[x] = find_parent(parent, parent[x])
    return parent[x]

# 두 노드가 속한 집합을 합침 (Union)
def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b

```

### 크루스칼 함수 동작 원리

```python
# 1. 모든 간선을 비용순으로 오름차순 정렬합니다.
edges.sort()

parent = [i for i in range(V + 1)] # 부모 테이블 자기 자신으로 초기화
total_weight = 0

for weight, a, b in edges:
    # 2. 두 노드의 루트 노드가 다르다면 (사이클이 발생하지 않는다면)
    if find_parent(parent, a) != find_parent(parent, b):
        # 3. 신축 트리에 포함시키고 연결(Union)합니다.
        union_parent(parent, a, b)
        total_weight += weight

```

### 프림(Prim) vs 크루스칼(Kruskal)

| 특징 | 프림 (Prim) | 크루스칼 (Kruskal) |
| --- | --- | --- |
| **핵심 전략** | 정점 위주 (가장 가까운 정점 선택) | 간선 위주 (가장 싼 간선 선택) |
| **자료 구조** | 우선순위 큐 (Heap), `visited` | 정렬 (Sort), `Union-Find` |
| **유리한 상황** | 간선이 매우 많은 **밀집 그래프** | 간선이 적은 **희소 그래프** |

### 결론

- **프림**은 다익스트라와 구조가 비슷해서 같이 공부하기 좋고,
- **크루스칼**은 코드가 직관적(정렬 후 선택)이라 구현이 더 쉬운 편입니다.
