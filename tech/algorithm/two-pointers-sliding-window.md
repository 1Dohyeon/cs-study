# Two Pointers (투 포인터)

## 1. 개요: "유동적인 그물망"

투 포인터는 수열 위에서 **왼쪽 포인터(`l`)**와 **오른쪽 포인터(`r`)**라는 두 개의 지점을 두고, 그 사이의 합(`s`)이 목표치(`M`)가 되는지 확인하는 기법입니다.

- **비유:** 두 사람이 긴 줄자를 들고 양쪽에서 길이를 조절하며 정확히 `M`cm가 되는 구간이 어디인지 찾아내는 것과 같습니다.
- **장점:** 처음부터 끝까지 한 번만 훑고 지나가면 되기 때문에(O(N)), 일일이 모든 구간을 다 더해보는 방식보다 훨씬 빠릅니다.

## 2. 동작 로직: 3가지 상황

지금 현재 손에 쥔 합(`s`)이 얼마냐에 따라 다음 행동이 결정됩니다.

### 상황 1: `s < M` (합이 부족)

- **행동:** 오른쪽 포인터(`r`)를 한 칸 뒤로 밀어 숫자를 더 추가합니다.
- **결과:** 구간이 넓어지면서 합이 커집니다. (`s += A[r]`)

### 상황 2: `s > M` (합이 너무 큼)

- **행동:** 왼쪽 포인터(`l`)를 한 칸 뒤로 당겨서 맨 앞의 숫자를 뺍니다.
- **결과:** 구간이 좁아지면서 합이 작아집니다. (`s -= A[l]`)

### 상황 3: `s == M` (정답 발견)

- **행동:** 경우의 수(`ans`)를 1 올리고, 다시 오른쪽 포인터(`r`)를 밀어 다음 후보를 찾습니다.

## 3. 코드 분석

```python
l, r = 0, 0
s = A[0] # 처음 구간은 첫 번째 숫자 하나만 잡고 시작
ans = 0

while l < N and r < N:
    if s < M:
        r += 1 # 오른쪽으로 확장
        if r < N: s += A[r]
    elif s > M:
        s -= A[l] # 왼쪽에서 축소
        l += 1
    else: # 정확히 M을 찾음
        ans += 1
        r += 1 # 또 다른 정답을 찾기 위해 다시 확장
        if r < N: s += A[r]

```

## 4. 왜 이 알고리즘을 쓸까?

만약 투 포인터를 안 쓰고 "모든 구간의 합"을 다 구한다면, `i`와 `j`를 일일이 정해서 다 더해야 합니다. 수열의 길이가 10,000이면 약 5,000만 번의 계산이 필요할 수 있습니다.

하지만 **투 포인터**를 쓰면:

1. 오른쪽 손(`r`)이 끝까지 한 번 가고,
2. 왼쪽 손(`l`)이 끝까지 한 번 따라가면 끝납니다.
3. **최대 20,000번 정도의 계산**만으로 답을 찾을 수 있습니다.

## 요약 비교

| 특징 | 완전 탐색 (이중 반복문) | 투 포인터 |
| --- | --- | --- |
| **비유** | 모든 구간을 일일이 다 잘라보기 | 줄자를 양쪽에서 밀고 당기기 |
| **속도** | 매우 느림 () | 매우 빠름 () |
| **핵심** | 모든 `i, j` 쌍을 다 확인 | 합이 작으면 늘리고, 크면 줄이기 |