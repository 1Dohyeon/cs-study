# Dijkstra (다익스트라 알고리즘)

## Dijkstra 개요

다익스트라는 **'최단 거리 내비게이션'** 입니다. 단순히 목적지까지 가는 길을 찾는 것이 아니라, 여러 갈래 길 중에서 **현재 시점에 가장 비용이 적게 드는 곳**부터 방문하여 전체 지도의 최단 거리 장부를 완성합니다.

- **최단 거리 장부 (`distance`)**: 출발지로부터 각 지점(노드)까지 가는 데 걸리는 최소 비용을 기록한 노트입니다. 처음에는 모두 `INF`(무한대)로 적어둡니다.
- **똑똑한 대기열 (`queue`)**: 방문할 후보지를 담아두는 바구니입니다. 일반적인 바구니와 달리, **거리(비용)가 짧은 순서대로** 물건을 꺼낼 수 있는 특수한 기능을 가집니다.
- **우선순위 큐 도구 (`heapq`)**: 똑똑한 대기열을 관리하는 파이썬의 도구입니다. 대기열에 새로운 후보지를 넣을 때마다 거리순으로 자동 정렬해 줍니다.

## Python 코드 구조 분석

### 0. 지도와 장부 준비

- `graph`: "어느 지점에서 어디로 갈 수 있고, 비용은 얼마인가?"를 저장합니다.
- `distance`: "시작점에서 여기까진 최소 얼마인가?"를 실시간으로 기록합니다.

### 1. 다익스트라 함수 동작 원리

```python
import heapq

def dijkstra(start_node):
    # 1. '똑똑한 대기열(queue)'을 준비합니다.
    # 이 대기열은 heapq를 통해 항상 비용이 가장 작은 데이터를 맨 앞으로 보내줍니다.
    queue = []
    
    # 2. 시작점을 대기열에 넣습니다. (비용 0, 시작지점)
    # heapq.heappush는 데이터를 넣을 때마다 비용순으로 자동 정렬해주는 도구입니다.
    heapq.heappush(queue, (0, start_node))
    # len(queue)는 1
    # 왜 queue.append()가 아니라 heapq를 쓰나요?
    # append()를 써도 데이터는 들어갑니다. 하지만 heapq.heappush()를 쓰는 이유는 '자동 정렬' 때문
    
    # 3. 장부의 시작 지점 거리를 0으로 적습니다. (자기 자신까지의 거리는 0)
    distance[start_node] = 0

    while queue:
        # 4. 대기열에서 "지금 장부상 가장 거리가 짧은 지점"을 꺼냅니다.
        # heapq.heappop은 대기열 맨 앞의 가장 작은 값을 꺼내줍니다.
        dist, now = heapq.heappop(queue)

        # 5. [이미 확인한 길인지 체크] 
        # 방금 꺼낸 정보가 이미 장부에 적힌 기록보다 더 길다면, 쓸모없는 정보이므로 무시합니다.
        if distance[now] < dist:
            continue

        # 6. 현재 지점과 연결된 이웃 지점들을 하나씩 살펴봅니다.
        for neighbor, weight in graph[now]:
            # cost = (현재 지점까지 온 거리) + (이웃 지점으로 가는 비용)
            cost = dist + weight
            
            # 7. [장부 갱신] "지금 찾은 길이 원래 장부에 적힌 길보다 더 빠르네?"
            if cost < distance[neighbor]:
                distance[neighbor] = cost # 장부를 더 짧은 기록으로 업데이트!
                # 새롭게 발견한 지름길 후보를 대기열에 추가합니다.
                heapq.heappush(queue, (cost, neighbor))

```

## 핵심 구성 요소의 역할

### 1. `queue` (똑똑한 대기열)

탐색해야 할 **'후보지 리스트'** 입니다. 다익스트라는 탐색 범위가 넓기 때문에, 아무 곳이나 먼저 가는 것이 아니라 **가장 가까운 곳부터** 가야 효율적입니다. `queue`는 그 순서를 지켜주는 대기실 역할을 합니다.

### 2. `heapq` (우선순위 큐 도구)

대기실에 들어온 후보자들을 **비용순으로 줄 세우는 관리자**입니다. 새로운 후보자가 들어올 때마다 일일이 수동으로 정렬할 필요 없이, `heapq`가 자동으로 가장 작은 비용을 가진 데이터를 맨 앞으로 배치해 줍니다.

### 3. `if distance[now] < dist: continue` (중복 검사)

장부는 계속 업데이트됩니다. 예전에 대기열에 넣었을 때는 최선이었던 길(예: 거리 10)이, 탐색 도중 더 짧은 길(예: 거리 5)로 장부가 이미 바뀌었을 수 있습니다. 이때 예전 정보(10)가 나오면 **"아, 이건 옛날 정보(불필요한 정보)구나"** 하고 버리는 과정입니다.

## 요약 비교

| 단계 | 역할 | 비유 |
|--|--|--|
| **`distance`** | 결과 저장 | 최단 거리 정보를 적어두는 **장부** |
| **`queue`** | 탐색 관리 | 다음에 방문할 후보지를 담은 **바구니** |
| **`heapq`** | 자동 정렬 | 바구니 속 물건을 거리순으로 배치하는 **도구** |
| **`cost < distance`** | 조건 검토 | "지름길인가?" 확인하는 **필터링** |

---

### 🗺️ 시뮬레이션 설정 (백준 1753 예제)

> [문제 풀이 코드](../../algorithm-ps/baekjoon/1753_최단경로.py)

* **정점**: 1번 ~ 5번 (시작점: **1번**)
* **간선 정보**:
* 1 → 2 (비용 2)
* 1 → 3 (비용 3)
* 2 → 3 (비용 4), 2 → 4 (비용 5)
* 3 → 4 (비용 6)
* 5 → 1 (비용 1)




### 0단계: 초기 세팅

* **장부(`distance`)**: `[0, INF, INF, INF, INF]` (1번만 0, 나머지는 무한대)
* **대기열(`queue`)**: `[(0, 1)]` (비용 0으로 1번 노드 방문 예정)


### 1단계: 1번 노드 방문 (pop)

1. **꺼내기**: 대기열에서 `(0, 1)`을 꺼냅니다. (이제 대기열은 빈 상태 `[]`)
2. **이웃 확인**: 1번에서 갈 수 있는 곳은 **2번(비용 2)** 과 **3번(비용 3)** 입니다.
3. **장부 갱신**:
- 2번: 0 + 2 = **2** (INF보다 작으므로 갱신)
- 3번: 0 + 3 = **3** (INF보다 작으므로 갱신)


4. **대기열 추가(push)**: `[(2, 2), (3, 3)]` (비용이 작은 2번이 맨 앞!)


### 2단계: 2번 노드 방문 (pop)

1. **꺼내기**: 대기열 맨 앞의 `(2, 2)`를 꺼냅니다. (남은 대기열: `[(3, 3)]`)
2. **이웃 확인**: 2번에서 갈 수 있는 곳은 **3번(비용 4)** 과 **4번(비용 5)** 입니다.
3. **장부 갱신**:
- 3번: 2 + 4 = 6 (현재 장부의 **3**보다 크므로 **무시**)
- 4번: 2 + 5 = **7** (INF보다 작으므로 갱신)


4. **대기열 추가(push)**: `[(3, 3), (7, 4)]`


### 3단계: 3번 노드 방문 (pop)

1. **꺼내기**: `(3, 3)`을 꺼냅니다. (남은 대기열: `[(7, 4)]`)
2. **이웃 확인**: 3번에서 갈 수 있는 곳은 **4번(비용 6)** 입니다.
3. **장부 갱신**:
* 4번: 3 + 6 = 9 (현재 장부의 **7**보다 크므로 **무시**)


4. **대기열 추가**: 새로 넣을 것이 없습니다.


### 4단계: 4번 노드 방문 (pop)

1. **꺼내기**: `(7, 4)`를 꺼냅니다. (이제 대기열은 다시 빈 상태 `[]`)
2. **이웃 확인**: 4번에서 갈 수 있는 곳이 없습니다.
3. **결과**: 대기열이 완전히 비었으므로 `while`문 종료


### 🏁 최종 결과 (출력)

장부(`distance`)에 적힌 최종 값들을 출력합니다.

| 노드 | 최종 거리 | 비고 |
|--|--|--|
| 1번 | **0** | 시작점 |
| 2번 | **2** | 1 → 2 |
| 3번 | **3** | 1 → 3 |
| 4번 | **7** | 1 → 2 → 4 (가장 빠름) |
| 5번 | **INF** | 갈 수 있는 방법이 없음 |

### 핵심 요약

1. `heappush`를 할 때마다 `queue`라는 리스트에 데이터가 쌓이고, `while queue:`는 그 데이터가 있는 동안 계속 돕니다.
2. `heappop`을 하면 리스트에서 데이터가 하나 사라집니다.
3. **"더 짧은 길을 찾았을 때만"** 다시 `heappush`를 하기 때문에, 언젠가는 대기열이 비게 되고 프로그램이 종료됩니다.
