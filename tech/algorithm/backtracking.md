# Backtracking (백트래킹)

## Backtracking 개요

백트래킹은 **'의사결정 나무 탐험'**입니다. 갈 수 있는 모든 경로를 탐색하되, 조건에 맞지 않으면 즉시 뒤로 돌아와서 다른 길을 찾는 전략입니다.

* **가지치기 (Pruning)**: 가보지 않아도 이 길이 정답이 아님을 안다면, 그쪽 방향은 과감히 포기하고 돌아옵니다. (시간 절약의 핵심)
* **상태 공간 트리**: 모든 경우의 수를 나무 모양으로 그렸을 때, 뿌리(시작)부터 나뭇가지(선택지)를 하나씩 타고 내려갑니다.
* **재귀와 복구**: 한 우물을 깊게 파고 들어갔다가(재귀), 다시 나와서 방금 했던 선택을 취소(복구)하고 옆 우물을 파는 과정을 반복합니다.

## Python으로 백트래킹 구현

### 0. 리스트로 수열 상태 표현

코드에서 `sequence` 리스트는 우리가 현재까지 길을 걸어오며 주머니에 담은 **'숫자 꾸러미'**입니다.

```python
sequence = []

# N=3, M=2인 경우 탐색 과정 예시
# 1. 1을 담음: [1]
# 2. 다음 숫자로 2를 담음: [1, 2] -> 출력! (M개 채워짐)
# 3. 2를 빼고 다시 돌아옴: [1] (복구)
# 4. 다음 숫자로 3을 담음: [1, 3] -> 출력!
# 5. 3을 빼고 다시 돌아옴: [1] -> 1도 빼고 처음으로: []

```

### 1. 백트래킹 함수 구조 분석

```python
def backtrack(sequence):
    # [탈출 조건] 바구니에 숫자가 M개 가득 찼다면?
    if len(sequence) == M:
        print(' '.join(map(str, sequence))) # 지금까지 모은 수열 출력
        return # 더 이상 내려가지 않고 '뒤로 돌아가기'

    # [탐색] 1부터 N까지의 숫자를 하나씩 넣어보기
    for i in range(1, N + 1):
        # 1. '중복 금지' 조건 확인 (가지치기)
        if i not in sequence:
            # 2. 숫자를 바구니에 넣고 다음 단계로 진입
            sequence.append(i)
            backtrack(sequence) # "이 숫자 넣었을 때 다음은 뭐가 올 수 있지?"
            
            # 3. 중요!! 탐색을 마치고 돌아오면 방금 넣은 숫자를 다시 뺌 (복구)
            # 다음 반복문에서 다른 숫자를 넣기 위해 자리를 비워주는 과정.
            sequence.pop() 

```

* **`sequence.append(i)`**: "일단 이 길로 가보자" (선택)
* **`backtrack(sequence)`**: "그다음 길은 어디?" (재귀 호출)
* **`sequence.pop()`**: "이 길은 다 봤으니 다시 갈림길로 돌아가서 다른 길로 가자." (원상 복구)

## 요약 비교

* **완전 탐색 (Brute-force)**
* 특징: 모든 경우의 수를 무식하게 다 가봄.
* 단점: 갈 필요 없는 길도 다 가기 때문에 매우 느림.


* **백트래킹 (Backtracking)**
* 특징: 일단 가보되, **조건에 안 맞으면(if i not in sequence)** 즉시 유턴.
* 장점: 정답이 될 가능성이 없는 경로는 미리 차단하므로 훨씬 효율적임.
